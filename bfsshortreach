def traverse(edge, bases):
    if not (edge[0] in bases):
        return edge[0]
    elif not (edge[1] in bases):
        return edge[1]
    else:
        return 0

def address_adjacent(steps, edges, nodes, bases, length):
    if edges == [] or nodes == []:
        return steps  
    adjacent_edges = [edge for edge in edges if (edge[0] in bases or edge[1] in bases)]
    for edge in adjacent_edges:
        edges.remove(edge)
    adjacent_nodes = filter(None, [traverse(edge, bases) for edge in adjacent_edges])
    for node in adjacent_nodes:
        try:
            nodes.remove(node)
        except ValueError:
            print node
        steps[node-1] = length
    return address_adjacent(steps, adjacent_edges, nodes, adjacent_nodes, length + 6)

def print_nodes(n, m, edges, s):
    steps = [-1] * n
    nodes = range(1, n+1)
    nodes.pop(s-1)
    bases = [s]
    steps = address_adjacent(steps, edges, nodes, bases, 6)
    steps.pop(s-1)
    print ' '.join(map(str, steps))

def perform_query():
    n, m = map(int, raw_input().split(' '))
    edges = []
    for m_i in range(0, m):
        edge = map(int, raw_input().split(' '))
        if not (sorted(edge) in edges):
            edges.append(edge)
    s = int(raw_input())
    print_nodes(n, m, edges, s)
    
q = int(raw_input())

for q_i in range(0, q):
    perform_query()
